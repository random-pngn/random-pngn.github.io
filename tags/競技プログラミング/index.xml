<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>競技プログラミング | Computer House Random</title>
    <link>https://ch-random.net/tags/%E7%AB%B6%E6%8A%80%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0/</link>
      <atom:link href="https://ch-random.net/tags/%E7%AB%B6%E6%8A%80%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0/index.xml" rel="self" type="application/rss+xml" />
    <description>競技プログラミング</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>ja</language><copyright>computer.house.random@gmail.com</copyright><lastBuildDate>Wed, 19 Feb 2020 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://ch-random.net/img/icon.png</url>
      <title>競技プログラミング</title>
      <link>https://ch-random.net/tags/%E7%AB%B6%E6%8A%80%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0/</link>
    </image>
    
    <item>
      <title>第3回競プロ勉強会</title>
      <link>https://ch-random.net/post/10/</link>
      <pubDate>Wed, 19 Feb 2020 00:00:00 +0000</pubDate>
      <guid>https://ch-random.net/post/10/</guid>
      <description>&lt;h1 id=&#34;heading&#34;&gt;はじめに&lt;/h1&gt;
&lt;p&gt;競プロ勉強会第3回です。今回は列に関するデータ構造です。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目次&lt;/p&gt;
&lt;p&gt;(水色向け)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;累積和&lt;/li&gt;
&lt;li&gt;imos法&lt;/li&gt;
&lt;li&gt;Segment Tree&lt;/li&gt;
&lt;li&gt;平方分割&lt;/li&gt;
&lt;li&gt;BIT&lt;/li&gt;
&lt;li&gt;動的Segment Tree&lt;/li&gt;
&lt;li&gt;遅延伝播Segment Tree&lt;/li&gt;
&lt;li&gt;Segment Tree beats&lt;/li&gt;
&lt;li&gt;Sparse Table&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;(青色向け)&lt;/p&gt;
&lt;ol start=&#34;10&#34;&gt;
&lt;li&gt;永続Segment Tree&lt;/li&gt;
&lt;li&gt;領域木 Fractional-Cascading&lt;/li&gt;
&lt;li&gt;Segment Tree上の二分探索&lt;/li&gt;
&lt;li&gt;平衡二分探索木treap&lt;/li&gt;
&lt;li&gt;平衡二分探索木treap&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;1-&#34;&gt;1. 累積和&lt;/h1&gt;
&lt;p&gt;(問題)数列$a_i$が与えられる。クエリl, rに対し、$a_l + a_{l+1} + &amp;hellip; + a_r$を求めよ&lt;/p&gt;
&lt;p&gt;有名問題ですね。$b_i = a_1 + a_2 + &amp;hellip; + a_i$と置き、最初に計算しておくと求めるものは$b_r-b_{l-1}$になりますね。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int a[100000], b[100001];
void build() {
  b[0] = 0;
  for (int i = 0; i &amp;lt; n; i++) b[i+1] = b[i] + a[i];
  // 簡単のためb_iを[0, i)の和として1個ずらしている
}
void get(int l, int r) {
  return b[r+1] - b[l];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;せっかくなのでclassで抽象化してしまいましょう。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class CumulativeSum {
  vector&amp;lt;int&amp;gt; a, b;
  bool flag;
  void build() {
    for (int i = 0; i &amp;lt; (int)a.size(); i++) b[i+1] = b[i] + a[i];
    flag = false;
  }
public:
  CumulativeSum(int n) : a(n, 0), b(n+1, 0) { flag = true; }
  CumulativeSum(vector&amp;lt;int&amp;gt; _a) : a(_a), b(_a.size() + 1, 0) { flag = true; }
  void change(int i, int x) {
    a[i] = x;
  }
  void add(int i, int x) {
    a[i] += x;
  }
  int get(int l, int r) { // [l, r)の範囲を求める
    if (flag) {
      build();
    }
    return b[r] - b[l];
    // 閉区間か半開区間かはお好きにどうぞ
  }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;累積和くらい何も見ずに30秒程度で書けるようになるべきですが、普段はライブラリを使えばいいと思います。コード量と時間の短縮になりますし、ライブラリ部分はバグらないですし、頭のリソースを累積和の実装に使いたくないので。みんなライブラリ整備しようね。&lt;/p&gt;
&lt;p&gt;累積和に載せられる代数構造は何でしょうか？答えは群です。そもそも基本的な代数構造を知らない人のために簡単な説明をしておきます。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;代数構造&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;マグマ&lt;/td&gt;
&lt;td&gt;集合とその集合上の二項演算&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;半群&lt;/td&gt;
&lt;td&gt;マグマ+結合則&lt;/td&gt;
&lt;td&gt;min, max, gcd&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;モノイド&lt;/td&gt;
&lt;td&gt;半群+単位元e(e*a=a*e=a)&lt;/td&gt;
&lt;td&gt;行列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;群&lt;/td&gt;
&lt;td&gt;モノイド+逆元&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;アーベル群&lt;/td&gt;
&lt;td&gt;群+可換則(a*b=b*a)&lt;/td&gt;
&lt;td&gt;足し算, 掛け算&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;get()の中を見れば分かりますが、+に対して-(逆元)が必要ですね。もし[0, i)の情報以外いらないのであれば半群でいけます。前回学んだ繰り返し二乗法は半群に対して実行可能です。&lt;/p&gt;
&lt;p&gt;単一の値更新がO(1)、構築がO(n)、範囲取得がO(1)です。動的な更新は効率的に行えません。&lt;/p&gt;
&lt;p&gt;ところで皆さん半開区間は好きですか？僕は大好きです。理由は簡単で閉区間だと区間の分割や併合で頭がバグるからです。細かい違いに見えるかもしれないですが、かなり変わります。意識してみて下さい。&lt;/p&gt;
&lt;h1 id=&#34;2-imos&#34;&gt;2. imos法&lt;/h1&gt;
&lt;p&gt;(問題)最初0がn個並んでいる。[l, r)の区間に+xをするクエリをq回行った後の数列を求めよ&lt;/p&gt;
&lt;p&gt;この数列の差分に着目してみましょう。l-1からlで+xされ、r-1からrで-xされますね。差分の変化はO(1)で計算できるので、差分の数列を持っておいてそれを元に構築すればよいですね。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class CumulativeSum {
  vector&amp;lt;int&amp;gt; a, diff;
  bool flag;
  void build() {
    for (int i = 0; i &amp;lt; (int)a.size(); i++) a[i+1] = a[i] + diff[i];
    flag = false;
  }
public:
  CumulativeSum(int n) : a(n+1, 0), diff(n, 0) { flag = true; }
  void add(int l, int r, int x) { // [l, r) +x
    diff[l] = x;
    diff[r] = -x;
  }
  int get(int i) {
    if (flag) {
      build();
    }
    return a[i+1];
  }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;範囲の値更新がO(1)、構築がO(n)、単一の値取得がO(1)です。動的な更新は効率的に行えません。&lt;/p&gt;
&lt;p&gt;数列の差分を見るという考え方は非常に重要で、高難易度の問題でも使われます。&lt;/p&gt;
&lt;h1 id=&#34;3-segment-tree&#34;&gt;3. Segment Tree&lt;/h1&gt;
&lt;p&gt;今日のメインディッシュです。モノイドに対して値の変更、区間演算をO(log n)で行うスグレモノです。イメージとしては下の画像のように完全二分木を作ると、任意の区間は高々O(log n)個の区間の和で表せるんですね。びっくりです。例えば[1, 7]は[1, 1], [2, 3], [4, 7]です。小さい例だと本当にlon nに落ちるか分かりにくいですね。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./segment-tree.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;適当に証明すると、完全二分木なので高さはlog nです。各行に対して選ばれるのは高々4個です。何故なら5個以上選ばれるなら3連続で選ばれる部分が存在し、その中の2連続のものうちどちらかは親が共通で、親を選ぶ方がよいからです。ガバガバですね。&lt;/p&gt;
&lt;p&gt;完全二分木の場合、根から順番に1, 2, 3, 4, 5,&amp;hellip;と番号をつけると各ノードiの親はi/2, 子供は2*i, 2*i+1です。indexが1から始まる事に注意して下さい。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;template &amp;lt;typename T&amp;gt;
class SegmentTree {
  int n;
  vector&amp;lt;T&amp;gt; node;
  function&amp;lt;T(T, T)&amp;gt; fun, fun2;
  bool customChange;
  T outValue, initValue;
public:
  SegmentTree(int num, function&amp;lt;T(T, T)&amp;gt; resultFunction, T init, T e, function&amp;lt;T(T, T)&amp;gt; changeFunction = NULL) {
    // changeFunction: (input, beforevalue) =&amp;gt; newvalue
    fun = resultFunction;
    fun2 = changeFunction;
    customChange = changeFunction != NULL;
    n = 1;
    while (n &amp;lt; num) n *= 2;
    node.resize(2 * n);
    fill(node.begin(), node.end(), init);
    outValue = e;
    initValue = init;
  }
  void change(int num, T value) {
    num += n-1;
    if (customChange) node[num] = fun2(value, node[num]);
    else node[num] = value;
    while (num &amp;gt; 0) num /= 2, node[num] = fun(node[num * 2], node[num * 2 + 1]);
  }
  T get(int a, int b, int l = 0, int r = -1, int k = 1) { // [a, b)
    if (r == -1) r = n;
    if (a &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;= b) return node[k]; // 完全に範囲内
    if (b &amp;lt;= l || r &amp;lt;= a) return outValue; //
    int mid = (l + r) / 2;
    return fun(rangeQuery(a, b, l, mid, 2*k), rangeQuery(a, b, mid, r, 2*k+1));
  }
};
// 個数, 演算, 初期値, 単位元(, 変更関数)を指定します
// int sum(int a, int b) { return a + b; }
// SegmentTree&amp;lt;int&amp;gt; sgt(n, sum, 0, 0);
// sgt.change(i, x); // i番目をxに変更
// sgt.get(a, b); // [a, b)の範囲の演算結果を返す
// もし、値の変更ではなく、元の値に追加したい時は
// SegmentTree&amp;lt;int&amp;gt; sgt(n, sum, 0, 0, sum);
// とすればよい(この仕様あまり好きじゃないけど)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最悪使い方さえ分かればいいです。かなり便利で、高難易度問題の一部によく使われます。簡単な問題もこれで殴れたりする。&lt;/p&gt;
&lt;p&gt;基本はモノイドに対して行えますが、単位元を無理やり作る事で半群も載せる事が出来ます。例えばminの単位元はINF, maxは-INF, gcdは0です。ちょっと頑張れば単位元が不要なSegment Treeも作れますが、[i, i)のクエリが飛んで来た時返す値に困るのでやめました。モノイドclassを分離するのがいいかも。&lt;/p&gt;
&lt;p&gt;単一の値更新がO(log n)、範囲取得がO(log n)です。動的に更新できます。&lt;/p&gt;
&lt;h1 id=&#34;4-&#34;&gt;4. 平方分割&lt;/h1&gt;
&lt;p&gt;セグメントツリーで不可能なクエリも要素を√n個に分割する事で色んなクエリがO(√n)で実行できます。セグメントツリーに比べて遅いですが、汎用的です。問題を見る方がいいでしょう。&lt;/p&gt;
&lt;h1 id=&#34;5-bit&#34;&gt;5. BIT&lt;/h1&gt;
&lt;p&gt;ほぼセグメントツリーと同じだがモノイドでは無くアーベル群に制限したもの。つまり、最小値を求めるクエリとかには対応できない。というか(int, +, 0)でしか見た事が無い。その分実装と定数倍が速い。&lt;/p&gt;
&lt;p&gt;コードは間に合いませんでした。&lt;/p&gt;
&lt;h1 id=&#34;6-segment-tree&#34;&gt;6. 動的Segment Tree&lt;/h1&gt;
&lt;p&gt;普通のSegment Treeは[0, n)の範囲なのでnが非常に大きい時はそのまま使えない。しかしオフラインクエリ(クエリが全部分かっている)の時は座標圧縮すると解けますが、オンラインクエリ(次のクエリが何か分からない)の時は使えません。だいたい座標圧縮でいけますが、オンラインクエリの時も動的Segment Treeを使えばよいです。&lt;/p&gt;
&lt;p&gt;やりたい事は簡単で、必要になるまで要素を作らない、値変更クエリが飛んできて初めて要素を作る感じです。&lt;/p&gt;
&lt;h1 id=&#34;7-segment-tree&#34;&gt;7. 遅延伝播Segment Tree&lt;/h1&gt;
&lt;p&gt;SegmentTreeは単一更新範囲取得が可能ですが、遅延伝播Segment Treeを使うと範囲更新が可能です。強いですね。その分実装と定数倍が重いです。これで殴れるって気づいたらライブラリを探しに行って下さい。いずれ書きます。&lt;/p&gt;
&lt;h1 id=&#34;8-segment-tree-beats&#34;&gt;8. Segment Tree beats&lt;/h1&gt;
&lt;p&gt;遅延伝播STは範囲更新の時、chminを行う事はできません。chminは元の値と与えられた値の小さい方に変更するクエリです。それをO($(log n)^2$)で行う事ができます。僕もまだ理解出来てません。できたら書きます。&lt;/p&gt;
&lt;h1 id=&#34;9-sparse-table&#34;&gt;9. Sparse Table&lt;/h1&gt;
&lt;p&gt;セグメントツリーの静的なやつで主にmin, maxに対して構築O(n log n)クエリO(1)にしたバージョンです。各点から$1, 2, 2^2, &amp;hellip;$の距離までの結果を持っておくと[a, b)のクエリは[a, a+2^t), [b-2^t, b)の解の&lt;/p&gt;
&lt;h1 id=&#34;11-swag&#34;&gt;11. SWAG&lt;/h1&gt;
&lt;h1 id=&#34;12-segment-tree&#34;&gt;12. 永続Segment Tree&lt;/h1&gt;
&lt;h1 id=&#34;13--fractional-cascading&#34;&gt;13. 領域木 Fractional-Cascading&lt;/h1&gt;
&lt;h1 id=&#34;14-segment-tree&#34;&gt;14. Segment Tree上の二分探索&lt;/h1&gt;
&lt;h1 id=&#34;15-treap&#34;&gt;15. 平衡二分探索木treap&lt;/h1&gt;
&lt;h1 id=&#34;16-treap&#34;&gt;16. 平衡二分探索木treap&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>第2回競プロ勉強会</title>
      <link>https://ch-random.net/post/7/</link>
      <pubDate>Wed, 12 Feb 2020 00:00:00 +0000</pubDate>
      <guid>https://ch-random.net/post/7/</guid>
      <description>&lt;h1 id=&#34;heading&#34;&gt;はじめに&lt;/h1&gt;
&lt;p&gt;競プロ勉強会第2回です。今回は数学的な話を中心にします。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目次&lt;/p&gt;
&lt;p&gt;(水色向け)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;逆元&lt;/li&gt;
&lt;li&gt;Combination&lt;/li&gt;
&lt;li&gt;素数&lt;/li&gt;
&lt;li&gt;gcd&lt;/li&gt;
&lt;li&gt;繰り返し二乗法&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;(青色向け)&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;包除原理&lt;/li&gt;
&lt;li&gt;FFT&lt;/li&gt;
&lt;li&gt;形式的冪級数&lt;/li&gt;
&lt;li&gt;行列&lt;/li&gt;
&lt;li&gt;対称性のある数え上げ&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;1-&#34;&gt;1. 逆元&lt;/h1&gt;
&lt;p&gt;xを整数、pを素数とすると、xの逆元yは$y \equiv x^{-1} (mod p)$と表す事ができ、$xy \equiv 1 (mod p)$を満たす整数です。これはyの取りうる値を0以上p-1以下とするとただ一つに定まります。&lt;br&gt;
(証明)a, bを0以上p-1以下とすると、$ax \equiv bx (mod p)$を満たす時$a = b$となるため。&lt;br&gt;
これ単体で聞かれる事はあまり無いですが、確率をmod pで整数で答えよ、や次のCombinationで用います。&lt;br&gt;
逆元を求める方法はフェルマーの小定理+繰り返し二乗法を用いる方法か拡張ユークリッドの互除法を用いる方法があります。&lt;br&gt;
フェルマーの小定理: 素数pとpと互いに素な整数aに対して$a^{p-1} \equiv 1$が成り立つ。&lt;br&gt;
(証明)$a^0$, $a^1$, &amp;hellip;, $a^{p-2}$はpで割ったあまりは全て異なる。&lt;br&gt;
同様に$a^1$, $a^2$, &amp;hellip;, $a^{p-1}$はpで割ったあまりは全て異なる。&lt;br&gt;
よって$a^0 \equiv a^{p-1}$&lt;/p&gt;
&lt;h1 id=&#34;2-combination&#34;&gt;2. Combination&lt;/h1&gt;
&lt;p&gt;みんな大好きCombinationです。nCkです。$\binom{n}{k}$と書きます。&lt;br&gt;
$\binom{n}{k} = \frac{n!}{k!(n-k)!}$ですね。これは横にk個、縦にn-k個の辺があるグリッドグラフで左下の点から右上の点に行く最短経路の総数ですね。&lt;/p&gt;
&lt;p&gt;$n!, (n!)^{-1} (mod p)$を前計算することでO(1)で求められます。&lt;br&gt;
ここで使える有用なテクニックなのですが、&lt;br&gt;
p = (p/n) * n + p%n&lt;br&gt;
(p/n) * n $\equiv$ -p%n (mod p)&lt;br&gt;
$n^{-1} \equiv$ -(p%n)$^{-1}$ * (p/n) (mod p)&lt;br&gt;
つまり、n!の逆元とp%(n+1)の逆元が求まれば(n+1)!の逆元が求まるわけです。p%(n+1)はn以下の整数なので、下から順番に記録しておくことで求められます。よって前計算はO(n)です。&lt;/p&gt;
&lt;p&gt;&amp;lt;基本公式&amp;gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\binom{n}{k} = \binom{n-1}{k-1} + \binom{n-1}{k}$
&lt;ul&gt;
&lt;li&gt;最初の1個を取るor取らない&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;$k\binom{n}{k} = n\binom{n-1}{k-1}$
&lt;ul&gt;
&lt;li&gt;$\frac{n!}{(n-k)!(k-1)!}$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;$\binom{n}{k} = \binom{n}{n-k}$
&lt;ul&gt;
&lt;li&gt;念の為&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;lt;公式&amp;gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\sum_{i=0}^{n} \binom{n}{i} = 2^n$
&lt;ul&gt;
&lt;li&gt;$(1 + 1)^n$の展開&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;$\sum_{i=0}^{n/2} \binom{n}{2i} = 2^{n-1}$
&lt;ul&gt;
&lt;li&gt;基本公式1を使ってΣを展開&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;$\sum_{i=0}^{k} \binom{n+i}{i} = \binom{n+k+1}{k}$
&lt;ul&gt;
&lt;li&gt;横k縦nのグリッドグラフの全ての上の部分への行き方の総和&lt;/li&gt;
&lt;li&gt;横k縦n+1のグリッドグラフの右上への行き方と等しい&lt;/li&gt;
&lt;li&gt;一番上の縦の辺は必ず1箇所通るから&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;$\sum_{i=0}^{k} \sum_{j=0}^{l} \binom{i+j}{i} = \binom{k+l+2}{k+1}$
&lt;ul&gt;
&lt;li&gt;公式3を2回&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;$\sum_{i=0}^{k} \binom{n+i}{i} \binom{m-i}{k-i} = \binom{n+m+1}{k}$
&lt;ul&gt;
&lt;li&gt;公式3の一般化&lt;/li&gt;
&lt;li&gt;横k縦n+m-k+1の縦をnとm-kに辺を1行あけて分割&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;$\sum_{i=0}^{k} \binom{n}{i} \binom{m}{k-i} = \binom{n+m}{k}$
&lt;ul&gt;
&lt;li&gt;横k縦n+m-kを斜めに切る感じ&lt;/li&gt;
&lt;li&gt;左は下からn, 右は上からmの点を通る直線&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc034/tasks/abc034_c&#34;&gt;練習問題&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;3-&#34;&gt;3. 素数&lt;/h1&gt;
&lt;p&gt;素数かどうかの判定はO($\sqrt{n}$)でできる。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bool is_Prime(int n) {
  for (int i = 2; i * i &amp;lt;= n; i++) {
    if (n % i == 0) return false;
  }
  return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同様に約数列挙とかもできる。素数を前計算で求める方法は、&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vector&amp;lt;int&amp;gt; get(int mx) {
  vector&amp;lt;int&amp;gt; prime;
  for (int i = 2; i &amp;lt;= mx; i++) {
    bool ok = true;
    for (int j : prime) {
      if (i % j == 0) {
        ok = false;
        break;
      }
    }
    if (ok) {
      prime.push_back(mx);
    }
  }
  return prime;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但し、これはそこそこ遅い。n&amp;lt;=10^6くらいで素数かどうかを判定するならエラトステネスのふるいを使うとよい。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bool isPrime[1000001]; // trueで初期化
void init(int mx) {
  isPrime[0] = isPrime[1] = false;
  for (int i = 2; i &amp;lt;= mx; i++) {
    if (isPrime[i]) {
      for (int j = 2; i * j &amp;lt;= mx; j++) isPrime[i * j] = false;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc084/tasks/abc084_d&#34;&gt;練習問題&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;4-gcd&#34;&gt;4. gcd&lt;/h1&gt;
&lt;p&gt;普通のgcd&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int gcd(int a, int b) {
  if (b == 0) return a;
  return gcd(b, a%b);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;拡張gcd ax+by=gとなるx, yもついでに求める。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int extgcd(int a, int b, int &amp;amp;x, int &amp;amp;y) {
  int d = a;
  if (b != 0) {
    d = extgcd(b, a%b, y, x);
    y -= (a/b) * x;
  } else {
    x = 1; y = 0;
  }
  return d;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;5-&#34;&gt;5. 繰り返し二乗法&lt;/h1&gt;
&lt;p&gt;$a^b$をO(log b)で解く。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int pw(int a, int b, int mod) {
  if (b == 0) return 1;
  if (b % 2 == 1) return pw(a, b-1, mod) * a % mod;
  int temp = pw(a, b/2, mod);
  return temp * temp % mod;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=NTL_1_B&amp;amp;lang=jp&#34;&gt;練習問題&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;行列とかにも使える。&lt;/p&gt;
&lt;h2 id=&#34;heading-1&#34;&gt;水色向け練習問題&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc110/tasks/abc110_d&#34;&gt;練習問題1&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://atcoder.jp/contests/abc132/tasks/abc132_d&#34;&gt;練習問題2&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://atcoder.jp/contests/abc013/tasks/abc013_4&#34;&gt;練習問題3&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;6-&#34;&gt;6. 包除原理&lt;/h1&gt;
&lt;p&gt;集合の数え上げの手法。ある部分集合がn個の集合に含まれる時、$(-1)^{n+1}$をかける。具体的には集合をbitで管理して、-1の(bitが立ってる個数+1)乗する。&lt;/p&gt;
&lt;p&gt;(工事中)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>第1回競プロ勉強会</title>
      <link>https://ch-random.net/post/5/</link>
      <pubDate>Wed, 05 Feb 2020 00:00:00 +0000</pubDate>
      <guid>https://ch-random.net/post/5/</guid>
      <description>&lt;h1 id=&#34;heading&#34;&gt;はじめに&lt;/h1&gt;
&lt;p&gt;競プロ勉強会第1回です。今回は探索を中心にやっていこうと思います。基本的に今回扱うのは全通りのパターンを列挙して調べる全探索のみ扱います。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目次&lt;/p&gt;
&lt;p&gt;(水色向け)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;再帰&lt;/li&gt;
&lt;li&gt;DFS&lt;/li&gt;
&lt;li&gt;BFS&lt;/li&gt;
&lt;li&gt;next_permutation&lt;/li&gt;
&lt;li&gt;bit全探索&lt;/li&gt;
&lt;li&gt;半分全列挙&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;(青色向け)&lt;/p&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;枝刈り&lt;/li&gt;
&lt;li&gt;IDA*&lt;/li&gt;
&lt;li&gt;A*&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;1-&#34;&gt;1. 再帰&lt;/h1&gt;
&lt;p&gt;これは探索とは直接関係無いのですが、皆さん再帰書けますか?再帰とはある概念をその概念自信で表す事です。&lt;br&gt;
例) フィボナッチ数列のn番目を求める再帰&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int fib(int n) {
  if (n == 1 || n == 2) return 1;
  return fib(n-1) + fib(n-2);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このコードは非常に効率が悪いですが、その話はまたいずれ。&lt;br&gt;
このコードには副作用が含まれないのできれいですが、競プロでは副作用のある関数を書きがちになります。注意しましょう。&lt;/p&gt;
&lt;h1 id=&#34;2-dfs&#34;&gt;2. DFS&lt;/h1&gt;
&lt;p&gt;深さ優先探索としてよく知られていますね。DFSは木やグラフを探索するアルゴリズムで、とりあえず根から下まで辿って、戻りながらまだ行って無い点があれば行くを繰り返す手法です。グラフと言いましたが、直接的なグラフじゃない一般の場合でも暗に状態がノードのグラフとみなす事で対応できます。&lt;br&gt;
突然難しい単語が出てきて頭がこんがらがっているかもしれないですが、てきとうに再帰を書くとそれがそのままDFSになります。&lt;br&gt;
DFSは探索順序が重要で無い場合に使える事が多いです。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc114/tasks/abc114_c&#34;&gt;練習問題&lt;/a&gt;
解答例&lt;/p&gt;
&lt;h1 id=&#34;3-bfs&#34;&gt;3. BFS&lt;/h1&gt;
&lt;p&gt;幅優先探索です。これはDFSとは探索順序が異なり、根から近い順に探索するアルゴリズムです。例えば迷路を解くプログラムで使われます。&lt;/p&gt;
&lt;p&gt;実装方法はおおまかに&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;queue X
Xに初期値を追加
while (!(Xが空)) {
  temp = Xの先頭要素
  Xの先頭要素の削除
  tempを元に探索し、次の探索位置をXに追加
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;でいけます。queueは最初に入れた値が最初に出てくるデータ構造です。恐らくこれだと分からないでしょうが、実際に練習問題を解いてみると理解できるでしょう。&lt;br&gt;
queueをstackにするとdfsに、priority_queueにするとダイクストラ法になります。&lt;br&gt;
但し、この形だと再帰のように探索の結果をまとめ上げるのが苦手です。一長一短ですね。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc007/tasks/abc007_3&#34;&gt;練習問題&lt;/a&gt;
解答例&lt;/p&gt;
&lt;h1 id=&#34;4-next-permutation&#34;&gt;4. next_permutation&lt;/h1&gt;
&lt;p&gt;これはC++の関数で、[1, 2, &amp;hellip; ,n]の並び替えn!通りを列挙してくれる関数です。使い方は少々独特で、&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//#include&amp;lt;algorithm&amp;gt;
int n = 5, d[5] = {1, 2, 3, 4, 5}; // 昇順に入れておく
do {
  // 処理
} while (next_permutation(d, d+n));

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多分O($n!n$)&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc150/tasks/abc150_c&#34;&gt;練習問題&lt;/a&gt;
解答例&lt;/p&gt;
&lt;h1 id=&#34;5-bit&#34;&gt;5. bit全探索&lt;/h1&gt;
&lt;p&gt;例えばn&amp;lt;=20くらいで、n個の商品を買うor買わないの$2^n$通り調べる必要がある時、i番目の商品をi番目のビットで管理する方法です。i番目のビットが1なら買う、0なら買わないみたいに管理します。&lt;/p&gt;
&lt;p&gt;例) n&amp;lt;=20でn個の商品に値段$d_i$がある。取りうる値段を全て列挙せよ。(重複している場合は重複している数だけ列挙する)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int n = 5, d[5] = {100, 20, 1000, 2, 30}; // dは商品の値段
for (int i = 0; i &amp;lt; (1&amp;lt;&amp;lt;n); i++) {
  int sum = 0;
  for (int j = 0; j &amp;lt; n; j++) {
    if (i &amp;amp; (1 &amp;lt;&amp;lt; j)) {
      // 買う
      sum += d[j];
    }
  }
  printf(&amp;quot;%d\n&amp;quot;, sum);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O($2^nn$)です。&lt;br&gt;
そもそもbit演算に慣れていない人も多いと思います。簡単にまとめると、&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;演算&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;a &amp;laquo; b&lt;/td&gt;
&lt;td&gt;aを左にbだけずらす&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a &amp;raquo; b&lt;/td&gt;
&lt;td&gt;aを右にbだけずらす&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;amp;&lt;/td&gt;
&lt;td&gt;bit積&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;|&lt;/td&gt;
&lt;td&gt;bit和&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;xor&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;です。詳細は検索して&lt;/p&gt;
&lt;p&gt;上のコードはbitを使わずdfsを用いて書く事もできます。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int n = 5, d[5] = {100, 20, 1000, 2, 30}; // dは商品の値段
void dfs(int num, int sum) {
  if (num == n) {
    printf(&amp;quot;%d\n&amp;quot;, sum);
    return;
  }
  dfs(num+1, sum);
  dfs(num+1, sum + d[num]);
}
// dfs(0, 0)で呼び出し
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;dfsでも書けるようになった方が良いでしょう。上のコードは副作用を含むのであまりきれいでは無いですが&amp;hellip;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc128/tasks/abc128_c&#34;&gt;練習問題&lt;/a&gt;
解答例&lt;/p&gt;
&lt;h1 id=&#34;6-&#34;&gt;6. 半分全列挙&lt;/h1&gt;
&lt;p&gt;n&amp;lt;=40くらいで、全探索するとO($2^n$)かかるけど、半分に分けてソートし、二分探索と組み合わせる事でO($2^{\frac{n}{2}}n$)に抑える方法。稀によく出る。&lt;/p&gt;
&lt;p&gt;例) n&amp;lt;=40 でn個の商品があり、値段$a_i$が与えられる。値段の和がちょうどkとなる選び方は何通り?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int n, a[40], k;
int half = n/2, rest = n - half;
vector&amp;lt;int&amp;gt; d;

// 前半2^half通り全列挙
for (int i = 0; i &amp;lt; (1&amp;lt;&amp;lt;half); i++) {
  int sum = 0;
  for (int j = 0; j &amp;lt; half; j++) {
    if (i &amp;amp; (1 &amp;lt;&amp;lt; j)) {
      sum += a[j];
    }
  }
  d.push_back(sum);
}
sort(d.begin(), d.end());

int ans = 0;
// 後半2^rest通り全列挙
for (int i = 0; i &amp;lt; (1&amp;lt;&amp;lt;rest); i++) {
  int sum = 0;
  for (int j = 0; j &amp;lt; rest; j++) {
    if (i &amp;amp; (1 &amp;lt;&amp;lt; j)) {
      sum += a[half + j];
    }
  }
  ans += upper_bound(d.begin(), d.end(), k - sum) - lower_bound(d.begin(), d.end(), k - sum);
  // 少々テクニカル
  // lower_bound, upper_boundは第三引数以上/より大きい最初の要素のポインタorイテレータを返す関数
  // ポインタやイテレータの引き算はその間の要素数になる
  // vectorのイテレータの引き算はO(1)だが、mapやsetとかのイテレータの引き算はO(n)だった気がするので注意
}

printf(&amp;quot;%lld\n&amp;quot;, ans);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;半分を全列挙するのにbit全探索を用いるときれいに書ける事が多いです。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/arc017/tasks/arc017_3&#34;&gt;練習問題&lt;/a&gt;
解答例&lt;/p&gt;
&lt;h2 id=&#34;heading-1&#34;&gt;水色向け練習問題&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc088/tasks/abc088_d&#34;&gt;練習問題1&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_1_H&amp;amp;lang=jp&#34;&gt;練習問題2&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://atcoder.jp/contests/agc033/tasks/agc033_a&#34;&gt;練習問題3&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://atcoder.jp/contests/abc054/tasks/abc054_c&#34;&gt;練習問題4&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;7-&#34;&gt;7. 枝刈り&lt;/h1&gt;
&lt;p&gt;枝刈りとは再帰関数で最適解となりえないと判断するとそこで探索を打ち切る事で高速化する手法です。アリ本では数独の問題が載っていました。計算量の解析が難しく、AtCoderの問題であまり見ない気がしますね。僕が解けない難しい問題だとあるのかも&amp;hellip;何にせよ、マラソンなどで使えるテクニックな気がしますね。&lt;/p&gt;
&lt;h1 id=&#34;8-&#34;&gt;8. 分枝限定法&lt;/h1&gt;
&lt;p&gt;(工事中)&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
